// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: g2ssadm.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_g2ssadm_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_g2ssadm_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_g2ssadm_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_g2ssadm_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_g2ssadm_2eproto;
namespace g2ssadm {
class CreateSaltInStoreRequest;
struct CreateSaltInStoreRequestDefaultTypeInternal;
extern CreateSaltInStoreRequestDefaultTypeInternal _CreateSaltInStoreRequest_default_instance_;
class CreateSaltInStoreResponse;
struct CreateSaltInStoreResponseDefaultTypeInternal;
extern CreateSaltInStoreResponseDefaultTypeInternal _CreateSaltInStoreResponse_default_instance_;
class DestroyRequest;
struct DestroyRequestDefaultTypeInternal;
extern DestroyRequestDefaultTypeInternal _DestroyRequest_default_instance_;
class DestroyResponse;
struct DestroyResponseDefaultTypeInternal;
extern DestroyResponseDefaultTypeInternal _DestroyResponse_default_instance_;
class InitRequest;
struct InitRequestDefaultTypeInternal;
extern InitRequestDefaultTypeInternal _InitRequest_default_instance_;
class InitResponse;
struct InitResponseDefaultTypeInternal;
extern InitResponseDefaultTypeInternal _InitResponse_default_instance_;
class InitializeNewTokenRequest;
struct InitializeNewTokenRequestDefaultTypeInternal;
extern InitializeNewTokenRequestDefaultTypeInternal _InitializeNewTokenRequest_default_instance_;
class InitializeNewTokenResponse;
struct InitializeNewTokenResponseDefaultTypeInternal;
extern InitializeNewTokenResponseDefaultTypeInternal _InitializeNewTokenResponse_default_instance_;
class ListRequest;
struct ListRequestDefaultTypeInternal;
extern ListRequestDefaultTypeInternal _ListRequest_default_instance_;
class ListResponse;
struct ListResponseDefaultTypeInternal;
extern ListResponseDefaultTypeInternal _ListResponse_default_instance_;
class PutRequest;
struct PutRequestDefaultTypeInternal;
extern PutRequestDefaultTypeInternal _PutRequest_default_instance_;
class PutResponse;
struct PutResponseDefaultTypeInternal;
extern PutResponseDefaultTypeInternal _PutResponse_default_instance_;
class ReinitializeTokenRequest;
struct ReinitializeTokenRequestDefaultTypeInternal;
extern ReinitializeTokenRequestDefaultTypeInternal _ReinitializeTokenRequest_default_instance_;
class ReinitializeTokenResponse;
struct ReinitializeTokenResponseDefaultTypeInternal;
extern ReinitializeTokenResponseDefaultTypeInternal _ReinitializeTokenResponse_default_instance_;
class SetupStoreRequest;
struct SetupStoreRequestDefaultTypeInternal;
extern SetupStoreRequestDefaultTypeInternal _SetupStoreRequest_default_instance_;
class SetupStoreResponse;
struct SetupStoreResponseDefaultTypeInternal;
extern SetupStoreResponseDefaultTypeInternal _SetupStoreResponse_default_instance_;
}  // namespace g2ssadm
PROTOBUF_NAMESPACE_OPEN
template<> ::g2ssadm::CreateSaltInStoreRequest* Arena::CreateMaybeMessage<::g2ssadm::CreateSaltInStoreRequest>(Arena*);
template<> ::g2ssadm::CreateSaltInStoreResponse* Arena::CreateMaybeMessage<::g2ssadm::CreateSaltInStoreResponse>(Arena*);
template<> ::g2ssadm::DestroyRequest* Arena::CreateMaybeMessage<::g2ssadm::DestroyRequest>(Arena*);
template<> ::g2ssadm::DestroyResponse* Arena::CreateMaybeMessage<::g2ssadm::DestroyResponse>(Arena*);
template<> ::g2ssadm::InitRequest* Arena::CreateMaybeMessage<::g2ssadm::InitRequest>(Arena*);
template<> ::g2ssadm::InitResponse* Arena::CreateMaybeMessage<::g2ssadm::InitResponse>(Arena*);
template<> ::g2ssadm::InitializeNewTokenRequest* Arena::CreateMaybeMessage<::g2ssadm::InitializeNewTokenRequest>(Arena*);
template<> ::g2ssadm::InitializeNewTokenResponse* Arena::CreateMaybeMessage<::g2ssadm::InitializeNewTokenResponse>(Arena*);
template<> ::g2ssadm::ListRequest* Arena::CreateMaybeMessage<::g2ssadm::ListRequest>(Arena*);
template<> ::g2ssadm::ListResponse* Arena::CreateMaybeMessage<::g2ssadm::ListResponse>(Arena*);
template<> ::g2ssadm::PutRequest* Arena::CreateMaybeMessage<::g2ssadm::PutRequest>(Arena*);
template<> ::g2ssadm::PutResponse* Arena::CreateMaybeMessage<::g2ssadm::PutResponse>(Arena*);
template<> ::g2ssadm::ReinitializeTokenRequest* Arena::CreateMaybeMessage<::g2ssadm::ReinitializeTokenRequest>(Arena*);
template<> ::g2ssadm::ReinitializeTokenResponse* Arena::CreateMaybeMessage<::g2ssadm::ReinitializeTokenResponse>(Arena*);
template<> ::g2ssadm::SetupStoreRequest* Arena::CreateMaybeMessage<::g2ssadm::SetupStoreRequest>(Arena*);
template<> ::g2ssadm::SetupStoreResponse* Arena::CreateMaybeMessage<::g2ssadm::SetupStoreResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace g2ssadm {

// ===================================================================

class CreateSaltInStoreRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2ssadm.CreateSaltInStoreRequest) */ {
 public:
  inline CreateSaltInStoreRequest() : CreateSaltInStoreRequest(nullptr) {}
  ~CreateSaltInStoreRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateSaltInStoreRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSaltInStoreRequest(const CreateSaltInStoreRequest& from);
  CreateSaltInStoreRequest(CreateSaltInStoreRequest&& from) noexcept
    : CreateSaltInStoreRequest() {
    *this = ::std::move(from);
  }

  inline CreateSaltInStoreRequest& operator=(const CreateSaltInStoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSaltInStoreRequest& operator=(CreateSaltInStoreRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSaltInStoreRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSaltInStoreRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSaltInStoreRequest*>(
               &_CreateSaltInStoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateSaltInStoreRequest& a, CreateSaltInStoreRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSaltInStoreRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSaltInStoreRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSaltInStoreRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSaltInStoreRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSaltInStoreRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateSaltInStoreRequest& from) {
    CreateSaltInStoreRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSaltInStoreRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.CreateSaltInStoreRequest";
  }
  protected:
  explicit CreateSaltInStoreRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoPinFieldNumber = 1,
    kNameFieldNumber = 2,
    kMethodFieldNumber = 3,
  };
  // string soPin = 1;
  void clear_sopin();
  const std::string& sopin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sopin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sopin();
  PROTOBUF_NODISCARD std::string* release_sopin();
  void set_allocated_sopin(std::string* sopin);
  private:
  const std::string& _internal_sopin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sopin(const std::string& value);
  std::string* _internal_mutable_sopin();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string method = 3;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // @@protoc_insertion_point(class_scope:g2ssadm.CreateSaltInStoreRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sopin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class CreateSaltInStoreResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2ssadm.CreateSaltInStoreResponse) */ {
 public:
  inline CreateSaltInStoreResponse() : CreateSaltInStoreResponse(nullptr) {}
  ~CreateSaltInStoreResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateSaltInStoreResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSaltInStoreResponse(const CreateSaltInStoreResponse& from);
  CreateSaltInStoreResponse(CreateSaltInStoreResponse&& from) noexcept
    : CreateSaltInStoreResponse() {
    *this = ::std::move(from);
  }

  inline CreateSaltInStoreResponse& operator=(const CreateSaltInStoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSaltInStoreResponse& operator=(CreateSaltInStoreResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSaltInStoreResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSaltInStoreResponse* internal_default_instance() {
    return reinterpret_cast<const CreateSaltInStoreResponse*>(
               &_CreateSaltInStoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateSaltInStoreResponse& a, CreateSaltInStoreResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSaltInStoreResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSaltInStoreResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSaltInStoreResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSaltInStoreResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSaltInStoreResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateSaltInStoreResponse& from) {
    CreateSaltInStoreResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSaltInStoreResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.CreateSaltInStoreResponse";
  }
  protected:
  explicit CreateSaltInStoreResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // string result = 1;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // @@protoc_insertion_point(class_scope:g2ssadm.CreateSaltInStoreResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class DestroyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2ssadm.DestroyRequest) */ {
 public:
  inline DestroyRequest() : DestroyRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DestroyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestroyRequest(const DestroyRequest& from);
  DestroyRequest(DestroyRequest&& from) noexcept
    : DestroyRequest() {
    *this = ::std::move(from);
  }

  inline DestroyRequest& operator=(const DestroyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestroyRequest& operator=(DestroyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestroyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestroyRequest* internal_default_instance() {
    return reinterpret_cast<const DestroyRequest*>(
               &_DestroyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DestroyRequest& a, DestroyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DestroyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestroyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestroyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestroyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DestroyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DestroyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.DestroyRequest";
  }
  protected:
  explicit DestroyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2ssadm.DestroyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class DestroyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2ssadm.DestroyResponse) */ {
 public:
  inline DestroyResponse() : DestroyResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DestroyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestroyResponse(const DestroyResponse& from);
  DestroyResponse(DestroyResponse&& from) noexcept
    : DestroyResponse() {
    *this = ::std::move(from);
  }

  inline DestroyResponse& operator=(const DestroyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestroyResponse& operator=(DestroyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestroyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestroyResponse* internal_default_instance() {
    return reinterpret_cast<const DestroyResponse*>(
               &_DestroyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DestroyResponse& a, DestroyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DestroyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestroyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestroyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestroyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DestroyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DestroyResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.DestroyResponse";
  }
  protected:
  explicit DestroyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2ssadm.DestroyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class InitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2ssadm.InitRequest) */ {
 public:
  inline InitRequest() : InitRequest(nullptr) {}
  ~InitRequest() override;
  explicit PROTOBUF_CONSTEXPR InitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitRequest(const InitRequest& from);
  InitRequest(InitRequest&& from) noexcept
    : InitRequest() {
    *this = ::std::move(from);
  }

  inline InitRequest& operator=(const InitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitRequest& operator=(InitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitRequest* internal_default_instance() {
    return reinterpret_cast<const InitRequest*>(
               &_InitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InitRequest& a, InitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitRequest& from) {
    InitRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.InitRequest";
  }
  protected:
  explicit InitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleNameFieldNumber = 1,
    kIniParamsFieldNumber = 2,
    kVerboseLoggingFieldNumber = 3,
  };
  // string moduleName = 1;
  void clear_modulename();
  const std::string& modulename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modulename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modulename();
  PROTOBUF_NODISCARD std::string* release_modulename();
  void set_allocated_modulename(std::string* modulename);
  private:
  const std::string& _internal_modulename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modulename(const std::string& value);
  std::string* _internal_mutable_modulename();
  public:

  // string iniParams = 2;
  void clear_iniparams();
  const std::string& iniparams() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iniparams(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iniparams();
  PROTOBUF_NODISCARD std::string* release_iniparams();
  void set_allocated_iniparams(std::string* iniparams);
  private:
  const std::string& _internal_iniparams() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iniparams(const std::string& value);
  std::string* _internal_mutable_iniparams();
  public:

  // int64 verboseLogging = 3;
  void clear_verboselogging();
  int64_t verboselogging() const;
  void set_verboselogging(int64_t value);
  private:
  int64_t _internal_verboselogging() const;
  void _internal_set_verboselogging(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:g2ssadm.InitRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modulename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iniparams_;
    int64_t verboselogging_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class InitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2ssadm.InitResponse) */ {
 public:
  inline InitResponse() : InitResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR InitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitResponse(const InitResponse& from);
  InitResponse(InitResponse&& from) noexcept
    : InitResponse() {
    *this = ::std::move(from);
  }

  inline InitResponse& operator=(const InitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitResponse& operator=(InitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitResponse* internal_default_instance() {
    return reinterpret_cast<const InitResponse*>(
               &_InitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InitResponse& a, InitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InitResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.InitResponse";
  }
  protected:
  explicit InitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2ssadm.InitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class InitializeNewTokenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2ssadm.InitializeNewTokenRequest) */ {
 public:
  inline InitializeNewTokenRequest() : InitializeNewTokenRequest(nullptr) {}
  ~InitializeNewTokenRequest() override;
  explicit PROTOBUF_CONSTEXPR InitializeNewTokenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitializeNewTokenRequest(const InitializeNewTokenRequest& from);
  InitializeNewTokenRequest(InitializeNewTokenRequest&& from) noexcept
    : InitializeNewTokenRequest() {
    *this = ::std::move(from);
  }

  inline InitializeNewTokenRequest& operator=(const InitializeNewTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitializeNewTokenRequest& operator=(InitializeNewTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitializeNewTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitializeNewTokenRequest* internal_default_instance() {
    return reinterpret_cast<const InitializeNewTokenRequest*>(
               &_InitializeNewTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InitializeNewTokenRequest& a, InitializeNewTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitializeNewTokenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitializeNewTokenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitializeNewTokenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitializeNewTokenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitializeNewTokenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitializeNewTokenRequest& from) {
    InitializeNewTokenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeNewTokenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.InitializeNewTokenRequest";
  }
  protected:
  explicit InitializeNewTokenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultSOPinFieldNumber = 1,
    kNewSOPinFieldNumber = 2,
    kLabelFieldNumber = 3,
  };
  // string defaultSOPin = 1;
  void clear_defaultsopin();
  const std::string& defaultsopin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_defaultsopin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_defaultsopin();
  PROTOBUF_NODISCARD std::string* release_defaultsopin();
  void set_allocated_defaultsopin(std::string* defaultsopin);
  private:
  const std::string& _internal_defaultsopin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_defaultsopin(const std::string& value);
  std::string* _internal_mutable_defaultsopin();
  public:

  // string newSOPin = 2;
  void clear_newsopin();
  const std::string& newsopin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newsopin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newsopin();
  PROTOBUF_NODISCARD std::string* release_newsopin();
  void set_allocated_newsopin(std::string* newsopin);
  private:
  const std::string& _internal_newsopin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newsopin(const std::string& value);
  std::string* _internal_mutable_newsopin();
  public:

  // string label = 3;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // @@protoc_insertion_point(class_scope:g2ssadm.InitializeNewTokenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr defaultsopin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newsopin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class InitializeNewTokenResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2ssadm.InitializeNewTokenResponse) */ {
 public:
  inline InitializeNewTokenResponse() : InitializeNewTokenResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR InitializeNewTokenResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitializeNewTokenResponse(const InitializeNewTokenResponse& from);
  InitializeNewTokenResponse(InitializeNewTokenResponse&& from) noexcept
    : InitializeNewTokenResponse() {
    *this = ::std::move(from);
  }

  inline InitializeNewTokenResponse& operator=(const InitializeNewTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitializeNewTokenResponse& operator=(InitializeNewTokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitializeNewTokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitializeNewTokenResponse* internal_default_instance() {
    return reinterpret_cast<const InitializeNewTokenResponse*>(
               &_InitializeNewTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InitializeNewTokenResponse& a, InitializeNewTokenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InitializeNewTokenResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitializeNewTokenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitializeNewTokenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitializeNewTokenResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InitializeNewTokenResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InitializeNewTokenResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.InitializeNewTokenResponse";
  }
  protected:
  explicit InitializeNewTokenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2ssadm.InitializeNewTokenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class ListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2ssadm.ListRequest) */ {
 public:
  inline ListRequest() : ListRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRequest(const ListRequest& from);
  ListRequest(ListRequest&& from) noexcept
    : ListRequest() {
    *this = ::std::move(from);
  }

  inline ListRequest& operator=(const ListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRequest& operator=(ListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRequest* internal_default_instance() {
    return reinterpret_cast<const ListRequest*>(
               &_ListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ListRequest& a, ListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.ListRequest";
  }
  protected:
  explicit ListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2ssadm.ListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class ListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2ssadm.ListResponse) */ {
 public:
  inline ListResponse() : ListResponse(nullptr) {}
  ~ListResponse() override;
  explicit PROTOBUF_CONSTEXPR ListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListResponse(const ListResponse& from);
  ListResponse(ListResponse&& from) noexcept
    : ListResponse() {
    *this = ::std::move(from);
  }

  inline ListResponse& operator=(const ListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListResponse& operator=(ListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListResponse* internal_default_instance() {
    return reinterpret_cast<const ListResponse*>(
               &_ListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ListResponse& a, ListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListResponse& from) {
    ListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.ListResponse";
  }
  protected:
  explicit ListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // string result = 1;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // @@protoc_insertion_point(class_scope:g2ssadm.ListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class PutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2ssadm.PutRequest) */ {
 public:
  inline PutRequest() : PutRequest(nullptr) {}
  ~PutRequest() override;
  explicit PROTOBUF_CONSTEXPR PutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutRequest(const PutRequest& from);
  PutRequest(PutRequest&& from) noexcept
    : PutRequest() {
    *this = ::std::move(from);
  }

  inline PutRequest& operator=(const PutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutRequest& operator=(PutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutRequest* internal_default_instance() {
    return reinterpret_cast<const PutRequest*>(
               &_PutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PutRequest& a, PutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PutRequest& from) {
    PutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.PutRequest";
  }
  protected:
  explicit PutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoPinFieldNumber = 1,
    kLabelFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // string soPin = 1;
  void clear_sopin();
  const std::string& sopin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sopin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sopin();
  PROTOBUF_NODISCARD std::string* release_sopin();
  void set_allocated_sopin(std::string* sopin);
  private:
  const std::string& _internal_sopin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sopin(const std::string& value);
  std::string* _internal_mutable_sopin();
  public:

  // string label = 2;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // string value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:g2ssadm.PutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sopin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class PutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2ssadm.PutResponse) */ {
 public:
  inline PutResponse() : PutResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PutResponse(const PutResponse& from);
  PutResponse(PutResponse&& from) noexcept
    : PutResponse() {
    *this = ::std::move(from);
  }

  inline PutResponse& operator=(const PutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PutResponse& operator=(PutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PutResponse* internal_default_instance() {
    return reinterpret_cast<const PutResponse*>(
               &_PutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PutResponse& a, PutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PutResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PutResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PutResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.PutResponse";
  }
  protected:
  explicit PutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2ssadm.PutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class ReinitializeTokenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2ssadm.ReinitializeTokenRequest) */ {
 public:
  inline ReinitializeTokenRequest() : ReinitializeTokenRequest(nullptr) {}
  ~ReinitializeTokenRequest() override;
  explicit PROTOBUF_CONSTEXPR ReinitializeTokenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReinitializeTokenRequest(const ReinitializeTokenRequest& from);
  ReinitializeTokenRequest(ReinitializeTokenRequest&& from) noexcept
    : ReinitializeTokenRequest() {
    *this = ::std::move(from);
  }

  inline ReinitializeTokenRequest& operator=(const ReinitializeTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReinitializeTokenRequest& operator=(ReinitializeTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReinitializeTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReinitializeTokenRequest* internal_default_instance() {
    return reinterpret_cast<const ReinitializeTokenRequest*>(
               &_ReinitializeTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ReinitializeTokenRequest& a, ReinitializeTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReinitializeTokenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReinitializeTokenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReinitializeTokenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReinitializeTokenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReinitializeTokenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReinitializeTokenRequest& from) {
    ReinitializeTokenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReinitializeTokenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.ReinitializeTokenRequest";
  }
  protected:
  explicit ReinitializeTokenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoPinFieldNumber = 1,
    kLabelFieldNumber = 2,
  };
  // string soPin = 1;
  void clear_sopin();
  const std::string& sopin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sopin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sopin();
  PROTOBUF_NODISCARD std::string* release_sopin();
  void set_allocated_sopin(std::string* sopin);
  private:
  const std::string& _internal_sopin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sopin(const std::string& value);
  std::string* _internal_mutable_sopin();
  public:

  // string label = 2;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // @@protoc_insertion_point(class_scope:g2ssadm.ReinitializeTokenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sopin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class ReinitializeTokenResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2ssadm.ReinitializeTokenResponse) */ {
 public:
  inline ReinitializeTokenResponse() : ReinitializeTokenResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReinitializeTokenResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReinitializeTokenResponse(const ReinitializeTokenResponse& from);
  ReinitializeTokenResponse(ReinitializeTokenResponse&& from) noexcept
    : ReinitializeTokenResponse() {
    *this = ::std::move(from);
  }

  inline ReinitializeTokenResponse& operator=(const ReinitializeTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReinitializeTokenResponse& operator=(ReinitializeTokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReinitializeTokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReinitializeTokenResponse* internal_default_instance() {
    return reinterpret_cast<const ReinitializeTokenResponse*>(
               &_ReinitializeTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ReinitializeTokenResponse& a, ReinitializeTokenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReinitializeTokenResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReinitializeTokenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReinitializeTokenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReinitializeTokenResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReinitializeTokenResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReinitializeTokenResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.ReinitializeTokenResponse";
  }
  protected:
  explicit ReinitializeTokenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2ssadm.ReinitializeTokenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class SetupStoreRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:g2ssadm.SetupStoreRequest) */ {
 public:
  inline SetupStoreRequest() : SetupStoreRequest(nullptr) {}
  ~SetupStoreRequest() override;
  explicit PROTOBUF_CONSTEXPR SetupStoreRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetupStoreRequest(const SetupStoreRequest& from);
  SetupStoreRequest(SetupStoreRequest&& from) noexcept
    : SetupStoreRequest() {
    *this = ::std::move(from);
  }

  inline SetupStoreRequest& operator=(const SetupStoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetupStoreRequest& operator=(SetupStoreRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetupStoreRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetupStoreRequest* internal_default_instance() {
    return reinterpret_cast<const SetupStoreRequest*>(
               &_SetupStoreRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SetupStoreRequest& a, SetupStoreRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetupStoreRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetupStoreRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetupStoreRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetupStoreRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetupStoreRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetupStoreRequest& from) {
    SetupStoreRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetupStoreRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.SetupStoreRequest";
  }
  protected:
  explicit SetupStoreRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoPinFieldNumber = 1,
  };
  // string soPin = 1;
  void clear_sopin();
  const std::string& sopin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sopin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sopin();
  PROTOBUF_NODISCARD std::string* release_sopin();
  void set_allocated_sopin(std::string* sopin);
  private:
  const std::string& _internal_sopin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sopin(const std::string& value);
  std::string* _internal_mutable_sopin();
  public:

  // @@protoc_insertion_point(class_scope:g2ssadm.SetupStoreRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sopin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// -------------------------------------------------------------------

class SetupStoreResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:g2ssadm.SetupStoreResponse) */ {
 public:
  inline SetupStoreResponse() : SetupStoreResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetupStoreResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetupStoreResponse(const SetupStoreResponse& from);
  SetupStoreResponse(SetupStoreResponse&& from) noexcept
    : SetupStoreResponse() {
    *this = ::std::move(from);
  }

  inline SetupStoreResponse& operator=(const SetupStoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetupStoreResponse& operator=(SetupStoreResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetupStoreResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetupStoreResponse* internal_default_instance() {
    return reinterpret_cast<const SetupStoreResponse*>(
               &_SetupStoreResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SetupStoreResponse& a, SetupStoreResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetupStoreResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetupStoreResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetupStoreResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetupStoreResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetupStoreResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetupStoreResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "g2ssadm.SetupStoreResponse";
  }
  protected:
  explicit SetupStoreResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:g2ssadm.SetupStoreResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_g2ssadm_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateSaltInStoreRequest

// string soPin = 1;
inline void CreateSaltInStoreRequest::clear_sopin() {
  _impl_.sopin_.ClearToEmpty();
}
inline const std::string& CreateSaltInStoreRequest::sopin() const {
  // @@protoc_insertion_point(field_get:g2ssadm.CreateSaltInStoreRequest.soPin)
  return _internal_sopin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSaltInStoreRequest::set_sopin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sopin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.CreateSaltInStoreRequest.soPin)
}
inline std::string* CreateSaltInStoreRequest::mutable_sopin() {
  std::string* _s = _internal_mutable_sopin();
  // @@protoc_insertion_point(field_mutable:g2ssadm.CreateSaltInStoreRequest.soPin)
  return _s;
}
inline const std::string& CreateSaltInStoreRequest::_internal_sopin() const {
  return _impl_.sopin_.Get();
}
inline void CreateSaltInStoreRequest::_internal_set_sopin(const std::string& value) {
  
  _impl_.sopin_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSaltInStoreRequest::_internal_mutable_sopin() {
  
  return _impl_.sopin_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSaltInStoreRequest::release_sopin() {
  // @@protoc_insertion_point(field_release:g2ssadm.CreateSaltInStoreRequest.soPin)
  return _impl_.sopin_.Release();
}
inline void CreateSaltInStoreRequest::set_allocated_sopin(std::string* sopin) {
  if (sopin != nullptr) {
    
  } else {
    
  }
  _impl_.sopin_.SetAllocated(sopin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sopin_.IsDefault()) {
    _impl_.sopin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.CreateSaltInStoreRequest.soPin)
}

// string name = 2;
inline void CreateSaltInStoreRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreateSaltInStoreRequest::name() const {
  // @@protoc_insertion_point(field_get:g2ssadm.CreateSaltInStoreRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSaltInStoreRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.CreateSaltInStoreRequest.name)
}
inline std::string* CreateSaltInStoreRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:g2ssadm.CreateSaltInStoreRequest.name)
  return _s;
}
inline const std::string& CreateSaltInStoreRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreateSaltInStoreRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSaltInStoreRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSaltInStoreRequest::release_name() {
  // @@protoc_insertion_point(field_release:g2ssadm.CreateSaltInStoreRequest.name)
  return _impl_.name_.Release();
}
inline void CreateSaltInStoreRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.CreateSaltInStoreRequest.name)
}

// string method = 3;
inline void CreateSaltInStoreRequest::clear_method() {
  _impl_.method_.ClearToEmpty();
}
inline const std::string& CreateSaltInStoreRequest::method() const {
  // @@protoc_insertion_point(field_get:g2ssadm.CreateSaltInStoreRequest.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSaltInStoreRequest::set_method(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.CreateSaltInStoreRequest.method)
}
inline std::string* CreateSaltInStoreRequest::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:g2ssadm.CreateSaltInStoreRequest.method)
  return _s;
}
inline const std::string& CreateSaltInStoreRequest::_internal_method() const {
  return _impl_.method_.Get();
}
inline void CreateSaltInStoreRequest::_internal_set_method(const std::string& value) {
  
  _impl_.method_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSaltInStoreRequest::_internal_mutable_method() {
  
  return _impl_.method_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSaltInStoreRequest::release_method() {
  // @@protoc_insertion_point(field_release:g2ssadm.CreateSaltInStoreRequest.method)
  return _impl_.method_.Release();
}
inline void CreateSaltInStoreRequest::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  _impl_.method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_.IsDefault()) {
    _impl_.method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.CreateSaltInStoreRequest.method)
}

// -------------------------------------------------------------------

// CreateSaltInStoreResponse

// string result = 1;
inline void CreateSaltInStoreResponse::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& CreateSaltInStoreResponse::result() const {
  // @@protoc_insertion_point(field_get:g2ssadm.CreateSaltInStoreResponse.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSaltInStoreResponse::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.CreateSaltInStoreResponse.result)
}
inline std::string* CreateSaltInStoreResponse::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:g2ssadm.CreateSaltInStoreResponse.result)
  return _s;
}
inline const std::string& CreateSaltInStoreResponse::_internal_result() const {
  return _impl_.result_.Get();
}
inline void CreateSaltInStoreResponse::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateSaltInStoreResponse::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateSaltInStoreResponse::release_result() {
  // @@protoc_insertion_point(field_release:g2ssadm.CreateSaltInStoreResponse.result)
  return _impl_.result_.Release();
}
inline void CreateSaltInStoreResponse::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.CreateSaltInStoreResponse.result)
}

// -------------------------------------------------------------------

// DestroyRequest

// -------------------------------------------------------------------

// DestroyResponse

// -------------------------------------------------------------------

// InitRequest

// string moduleName = 1;
inline void InitRequest::clear_modulename() {
  _impl_.modulename_.ClearToEmpty();
}
inline const std::string& InitRequest::modulename() const {
  // @@protoc_insertion_point(field_get:g2ssadm.InitRequest.moduleName)
  return _internal_modulename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitRequest::set_modulename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.modulename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.InitRequest.moduleName)
}
inline std::string* InitRequest::mutable_modulename() {
  std::string* _s = _internal_mutable_modulename();
  // @@protoc_insertion_point(field_mutable:g2ssadm.InitRequest.moduleName)
  return _s;
}
inline const std::string& InitRequest::_internal_modulename() const {
  return _impl_.modulename_.Get();
}
inline void InitRequest::_internal_set_modulename(const std::string& value) {
  
  _impl_.modulename_.Set(value, GetArenaForAllocation());
}
inline std::string* InitRequest::_internal_mutable_modulename() {
  
  return _impl_.modulename_.Mutable(GetArenaForAllocation());
}
inline std::string* InitRequest::release_modulename() {
  // @@protoc_insertion_point(field_release:g2ssadm.InitRequest.moduleName)
  return _impl_.modulename_.Release();
}
inline void InitRequest::set_allocated_modulename(std::string* modulename) {
  if (modulename != nullptr) {
    
  } else {
    
  }
  _impl_.modulename_.SetAllocated(modulename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.modulename_.IsDefault()) {
    _impl_.modulename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.InitRequest.moduleName)
}

// string iniParams = 2;
inline void InitRequest::clear_iniparams() {
  _impl_.iniparams_.ClearToEmpty();
}
inline const std::string& InitRequest::iniparams() const {
  // @@protoc_insertion_point(field_get:g2ssadm.InitRequest.iniParams)
  return _internal_iniparams();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitRequest::set_iniparams(ArgT0&& arg0, ArgT... args) {
 
 _impl_.iniparams_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.InitRequest.iniParams)
}
inline std::string* InitRequest::mutable_iniparams() {
  std::string* _s = _internal_mutable_iniparams();
  // @@protoc_insertion_point(field_mutable:g2ssadm.InitRequest.iniParams)
  return _s;
}
inline const std::string& InitRequest::_internal_iniparams() const {
  return _impl_.iniparams_.Get();
}
inline void InitRequest::_internal_set_iniparams(const std::string& value) {
  
  _impl_.iniparams_.Set(value, GetArenaForAllocation());
}
inline std::string* InitRequest::_internal_mutable_iniparams() {
  
  return _impl_.iniparams_.Mutable(GetArenaForAllocation());
}
inline std::string* InitRequest::release_iniparams() {
  // @@protoc_insertion_point(field_release:g2ssadm.InitRequest.iniParams)
  return _impl_.iniparams_.Release();
}
inline void InitRequest::set_allocated_iniparams(std::string* iniparams) {
  if (iniparams != nullptr) {
    
  } else {
    
  }
  _impl_.iniparams_.SetAllocated(iniparams, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.iniparams_.IsDefault()) {
    _impl_.iniparams_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.InitRequest.iniParams)
}

// int64 verboseLogging = 3;
inline void InitRequest::clear_verboselogging() {
  _impl_.verboselogging_ = int64_t{0};
}
inline int64_t InitRequest::_internal_verboselogging() const {
  return _impl_.verboselogging_;
}
inline int64_t InitRequest::verboselogging() const {
  // @@protoc_insertion_point(field_get:g2ssadm.InitRequest.verboseLogging)
  return _internal_verboselogging();
}
inline void InitRequest::_internal_set_verboselogging(int64_t value) {
  
  _impl_.verboselogging_ = value;
}
inline void InitRequest::set_verboselogging(int64_t value) {
  _internal_set_verboselogging(value);
  // @@protoc_insertion_point(field_set:g2ssadm.InitRequest.verboseLogging)
}

// -------------------------------------------------------------------

// InitResponse

// -------------------------------------------------------------------

// InitializeNewTokenRequest

// string defaultSOPin = 1;
inline void InitializeNewTokenRequest::clear_defaultsopin() {
  _impl_.defaultsopin_.ClearToEmpty();
}
inline const std::string& InitializeNewTokenRequest::defaultsopin() const {
  // @@protoc_insertion_point(field_get:g2ssadm.InitializeNewTokenRequest.defaultSOPin)
  return _internal_defaultsopin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitializeNewTokenRequest::set_defaultsopin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.defaultsopin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.InitializeNewTokenRequest.defaultSOPin)
}
inline std::string* InitializeNewTokenRequest::mutable_defaultsopin() {
  std::string* _s = _internal_mutable_defaultsopin();
  // @@protoc_insertion_point(field_mutable:g2ssadm.InitializeNewTokenRequest.defaultSOPin)
  return _s;
}
inline const std::string& InitializeNewTokenRequest::_internal_defaultsopin() const {
  return _impl_.defaultsopin_.Get();
}
inline void InitializeNewTokenRequest::_internal_set_defaultsopin(const std::string& value) {
  
  _impl_.defaultsopin_.Set(value, GetArenaForAllocation());
}
inline std::string* InitializeNewTokenRequest::_internal_mutable_defaultsopin() {
  
  return _impl_.defaultsopin_.Mutable(GetArenaForAllocation());
}
inline std::string* InitializeNewTokenRequest::release_defaultsopin() {
  // @@protoc_insertion_point(field_release:g2ssadm.InitializeNewTokenRequest.defaultSOPin)
  return _impl_.defaultsopin_.Release();
}
inline void InitializeNewTokenRequest::set_allocated_defaultsopin(std::string* defaultsopin) {
  if (defaultsopin != nullptr) {
    
  } else {
    
  }
  _impl_.defaultsopin_.SetAllocated(defaultsopin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.defaultsopin_.IsDefault()) {
    _impl_.defaultsopin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.InitializeNewTokenRequest.defaultSOPin)
}

// string newSOPin = 2;
inline void InitializeNewTokenRequest::clear_newsopin() {
  _impl_.newsopin_.ClearToEmpty();
}
inline const std::string& InitializeNewTokenRequest::newsopin() const {
  // @@protoc_insertion_point(field_get:g2ssadm.InitializeNewTokenRequest.newSOPin)
  return _internal_newsopin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitializeNewTokenRequest::set_newsopin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.newsopin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.InitializeNewTokenRequest.newSOPin)
}
inline std::string* InitializeNewTokenRequest::mutable_newsopin() {
  std::string* _s = _internal_mutable_newsopin();
  // @@protoc_insertion_point(field_mutable:g2ssadm.InitializeNewTokenRequest.newSOPin)
  return _s;
}
inline const std::string& InitializeNewTokenRequest::_internal_newsopin() const {
  return _impl_.newsopin_.Get();
}
inline void InitializeNewTokenRequest::_internal_set_newsopin(const std::string& value) {
  
  _impl_.newsopin_.Set(value, GetArenaForAllocation());
}
inline std::string* InitializeNewTokenRequest::_internal_mutable_newsopin() {
  
  return _impl_.newsopin_.Mutable(GetArenaForAllocation());
}
inline std::string* InitializeNewTokenRequest::release_newsopin() {
  // @@protoc_insertion_point(field_release:g2ssadm.InitializeNewTokenRequest.newSOPin)
  return _impl_.newsopin_.Release();
}
inline void InitializeNewTokenRequest::set_allocated_newsopin(std::string* newsopin) {
  if (newsopin != nullptr) {
    
  } else {
    
  }
  _impl_.newsopin_.SetAllocated(newsopin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.newsopin_.IsDefault()) {
    _impl_.newsopin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.InitializeNewTokenRequest.newSOPin)
}

// string label = 3;
inline void InitializeNewTokenRequest::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& InitializeNewTokenRequest::label() const {
  // @@protoc_insertion_point(field_get:g2ssadm.InitializeNewTokenRequest.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitializeNewTokenRequest::set_label(ArgT0&& arg0, ArgT... args) {
 
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.InitializeNewTokenRequest.label)
}
inline std::string* InitializeNewTokenRequest::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:g2ssadm.InitializeNewTokenRequest.label)
  return _s;
}
inline const std::string& InitializeNewTokenRequest::_internal_label() const {
  return _impl_.label_.Get();
}
inline void InitializeNewTokenRequest::_internal_set_label(const std::string& value) {
  
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* InitializeNewTokenRequest::_internal_mutable_label() {
  
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* InitializeNewTokenRequest::release_label() {
  // @@protoc_insertion_point(field_release:g2ssadm.InitializeNewTokenRequest.label)
  return _impl_.label_.Release();
}
inline void InitializeNewTokenRequest::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.InitializeNewTokenRequest.label)
}

// -------------------------------------------------------------------

// InitializeNewTokenResponse

// -------------------------------------------------------------------

// ListRequest

// -------------------------------------------------------------------

// ListResponse

// string result = 1;
inline void ListResponse::clear_result() {
  _impl_.result_.ClearToEmpty();
}
inline const std::string& ListResponse::result() const {
  // @@protoc_insertion_point(field_get:g2ssadm.ListResponse.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListResponse::set_result(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.ListResponse.result)
}
inline std::string* ListResponse::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:g2ssadm.ListResponse.result)
  return _s;
}
inline const std::string& ListResponse::_internal_result() const {
  return _impl_.result_.Get();
}
inline void ListResponse::_internal_set_result(const std::string& value) {
  
  _impl_.result_.Set(value, GetArenaForAllocation());
}
inline std::string* ListResponse::_internal_mutable_result() {
  
  return _impl_.result_.Mutable(GetArenaForAllocation());
}
inline std::string* ListResponse::release_result() {
  // @@protoc_insertion_point(field_release:g2ssadm.ListResponse.result)
  return _impl_.result_.Release();
}
inline void ListResponse::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  _impl_.result_.SetAllocated(result, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_.IsDefault()) {
    _impl_.result_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.ListResponse.result)
}

// -------------------------------------------------------------------

// PutRequest

// string soPin = 1;
inline void PutRequest::clear_sopin() {
  _impl_.sopin_.ClearToEmpty();
}
inline const std::string& PutRequest::sopin() const {
  // @@protoc_insertion_point(field_get:g2ssadm.PutRequest.soPin)
  return _internal_sopin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutRequest::set_sopin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sopin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.PutRequest.soPin)
}
inline std::string* PutRequest::mutable_sopin() {
  std::string* _s = _internal_mutable_sopin();
  // @@protoc_insertion_point(field_mutable:g2ssadm.PutRequest.soPin)
  return _s;
}
inline const std::string& PutRequest::_internal_sopin() const {
  return _impl_.sopin_.Get();
}
inline void PutRequest::_internal_set_sopin(const std::string& value) {
  
  _impl_.sopin_.Set(value, GetArenaForAllocation());
}
inline std::string* PutRequest::_internal_mutable_sopin() {
  
  return _impl_.sopin_.Mutable(GetArenaForAllocation());
}
inline std::string* PutRequest::release_sopin() {
  // @@protoc_insertion_point(field_release:g2ssadm.PutRequest.soPin)
  return _impl_.sopin_.Release();
}
inline void PutRequest::set_allocated_sopin(std::string* sopin) {
  if (sopin != nullptr) {
    
  } else {
    
  }
  _impl_.sopin_.SetAllocated(sopin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sopin_.IsDefault()) {
    _impl_.sopin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.PutRequest.soPin)
}

// string label = 2;
inline void PutRequest::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& PutRequest::label() const {
  // @@protoc_insertion_point(field_get:g2ssadm.PutRequest.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutRequest::set_label(ArgT0&& arg0, ArgT... args) {
 
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.PutRequest.label)
}
inline std::string* PutRequest::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:g2ssadm.PutRequest.label)
  return _s;
}
inline const std::string& PutRequest::_internal_label() const {
  return _impl_.label_.Get();
}
inline void PutRequest::_internal_set_label(const std::string& value) {
  
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* PutRequest::_internal_mutable_label() {
  
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* PutRequest::release_label() {
  // @@protoc_insertion_point(field_release:g2ssadm.PutRequest.label)
  return _impl_.label_.Release();
}
inline void PutRequest::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.PutRequest.label)
}

// string value = 3;
inline void PutRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& PutRequest::value() const {
  // @@protoc_insertion_point(field_get:g2ssadm.PutRequest.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PutRequest::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.PutRequest.value)
}
inline std::string* PutRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:g2ssadm.PutRequest.value)
  return _s;
}
inline const std::string& PutRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void PutRequest::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* PutRequest::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* PutRequest::release_value() {
  // @@protoc_insertion_point(field_release:g2ssadm.PutRequest.value)
  return _impl_.value_.Release();
}
inline void PutRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.PutRequest.value)
}

// -------------------------------------------------------------------

// PutResponse

// -------------------------------------------------------------------

// ReinitializeTokenRequest

// string soPin = 1;
inline void ReinitializeTokenRequest::clear_sopin() {
  _impl_.sopin_.ClearToEmpty();
}
inline const std::string& ReinitializeTokenRequest::sopin() const {
  // @@protoc_insertion_point(field_get:g2ssadm.ReinitializeTokenRequest.soPin)
  return _internal_sopin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReinitializeTokenRequest::set_sopin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sopin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.ReinitializeTokenRequest.soPin)
}
inline std::string* ReinitializeTokenRequest::mutable_sopin() {
  std::string* _s = _internal_mutable_sopin();
  // @@protoc_insertion_point(field_mutable:g2ssadm.ReinitializeTokenRequest.soPin)
  return _s;
}
inline const std::string& ReinitializeTokenRequest::_internal_sopin() const {
  return _impl_.sopin_.Get();
}
inline void ReinitializeTokenRequest::_internal_set_sopin(const std::string& value) {
  
  _impl_.sopin_.Set(value, GetArenaForAllocation());
}
inline std::string* ReinitializeTokenRequest::_internal_mutable_sopin() {
  
  return _impl_.sopin_.Mutable(GetArenaForAllocation());
}
inline std::string* ReinitializeTokenRequest::release_sopin() {
  // @@protoc_insertion_point(field_release:g2ssadm.ReinitializeTokenRequest.soPin)
  return _impl_.sopin_.Release();
}
inline void ReinitializeTokenRequest::set_allocated_sopin(std::string* sopin) {
  if (sopin != nullptr) {
    
  } else {
    
  }
  _impl_.sopin_.SetAllocated(sopin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sopin_.IsDefault()) {
    _impl_.sopin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.ReinitializeTokenRequest.soPin)
}

// string label = 2;
inline void ReinitializeTokenRequest::clear_label() {
  _impl_.label_.ClearToEmpty();
}
inline const std::string& ReinitializeTokenRequest::label() const {
  // @@protoc_insertion_point(field_get:g2ssadm.ReinitializeTokenRequest.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReinitializeTokenRequest::set_label(ArgT0&& arg0, ArgT... args) {
 
 _impl_.label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.ReinitializeTokenRequest.label)
}
inline std::string* ReinitializeTokenRequest::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:g2ssadm.ReinitializeTokenRequest.label)
  return _s;
}
inline const std::string& ReinitializeTokenRequest::_internal_label() const {
  return _impl_.label_.Get();
}
inline void ReinitializeTokenRequest::_internal_set_label(const std::string& value) {
  
  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* ReinitializeTokenRequest::_internal_mutable_label() {
  
  return _impl_.label_.Mutable(GetArenaForAllocation());
}
inline std::string* ReinitializeTokenRequest::release_label() {
  // @@protoc_insertion_point(field_release:g2ssadm.ReinitializeTokenRequest.label)
  return _impl_.label_.Release();
}
inline void ReinitializeTokenRequest::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  _impl_.label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.ReinitializeTokenRequest.label)
}

// -------------------------------------------------------------------

// ReinitializeTokenResponse

// -------------------------------------------------------------------

// SetupStoreRequest

// string soPin = 1;
inline void SetupStoreRequest::clear_sopin() {
  _impl_.sopin_.ClearToEmpty();
}
inline const std::string& SetupStoreRequest::sopin() const {
  // @@protoc_insertion_point(field_get:g2ssadm.SetupStoreRequest.soPin)
  return _internal_sopin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetupStoreRequest::set_sopin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sopin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:g2ssadm.SetupStoreRequest.soPin)
}
inline std::string* SetupStoreRequest::mutable_sopin() {
  std::string* _s = _internal_mutable_sopin();
  // @@protoc_insertion_point(field_mutable:g2ssadm.SetupStoreRequest.soPin)
  return _s;
}
inline const std::string& SetupStoreRequest::_internal_sopin() const {
  return _impl_.sopin_.Get();
}
inline void SetupStoreRequest::_internal_set_sopin(const std::string& value) {
  
  _impl_.sopin_.Set(value, GetArenaForAllocation());
}
inline std::string* SetupStoreRequest::_internal_mutable_sopin() {
  
  return _impl_.sopin_.Mutable(GetArenaForAllocation());
}
inline std::string* SetupStoreRequest::release_sopin() {
  // @@protoc_insertion_point(field_release:g2ssadm.SetupStoreRequest.soPin)
  return _impl_.sopin_.Release();
}
inline void SetupStoreRequest::set_allocated_sopin(std::string* sopin) {
  if (sopin != nullptr) {
    
  } else {
    
  }
  _impl_.sopin_.SetAllocated(sopin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sopin_.IsDefault()) {
    _impl_.sopin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:g2ssadm.SetupStoreRequest.soPin)
}

// -------------------------------------------------------------------

// SetupStoreResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace g2ssadm

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_g2ssadm_2eproto
